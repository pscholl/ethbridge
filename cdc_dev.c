#include "contiki.h"
#include "usb.h"
#include "gdb2.h"
#include "mac.h"
#include "net/rime.h"
#include "net/uip.h"
#include "AppApi.h"
#include "dev/leds.h"
#include "ethbridge.h"

void (*cdc_tcpip_input)() = tcpip_input;
static bool enumerated    = false;

u8_t
cdc_output(uip_lladdr_t *a)
{
  if (!enumerated)
    return 0;
  else
    return usb_write(EP2, uip_buf, uip_len);
}

PROCESS(cdc_process, "Jennic/Max3420 CDC Ethernet Process");

void
cdc_init()
{
  process_start(&cdc_process, NULL);
}

const struct mac_driver cdc_driver = {
  "CDC Ethernet Driver",
  cdc_init
};

typedef struct
{
  uint8_t  bmRequestType;
  uint8_t  bNotificationType;
  uint16_t wValue;
  uint16_t wIndex;
  uint16_t wLength;
  uint32_t data[2];
} cdc_notification_t;

/*
 * Class-Specific Notifications (6.3) sent by interrupt transfers
 */
#define CDC_NOTIFY_TYPE                 0xa1
#define CDC_NOTIFY_NETWORK_CONNECTION   0x00
#define CDC_NOTIFY_SPEED_CHANGE         0x2a

static bool
cdc_send_status()
{
  bool status = true;
  cdc_notification_t notify;

  /* set network connection UP */
  notify.bmRequestType = CDC_NOTIFY_TYPE;
  notify.bNotificationType = CDC_NOTIFY_NETWORK_CONNECTION;
  notify.wValue  = HTOUS(1);
  notify.wIndex  = HTOUS(1);
  notify.wLength = 0;
  status &= usb_write(EP3, (uint8_t*) &notify, sizeof(notify)-sizeof(notify.data))>0;

  /* set input and output speed to 250 kbps */
  notify.bmRequestType = CDC_NOTIFY_TYPE;
  notify.bNotificationType = CDC_NOTIFY_SPEED_CHANGE;
  notify.wValue  = 0;
  notify.wIndex  = HTOUS(1);
  notify.wLength = HTOUS(sizeof(notify.data));
  notify.data[0] = notify.data[1] = HTOUL(250*1000);
  status &= usb_write(EP3, (uint8_t*) &notify, sizeof(notify))>0;

  return status;
}

void
cdc_set_mac(usbdev_t *usbdev, char *mac)
  /** special hack to load our ieee802.3 mac address into the device
   * descriptor. We *assume* that iMacAddress in the descriptor is 1,
   * which is why we store the mac adress there. */
{
#define nibblehi(x) (((x)>>4)&0x0f)
#define nibblelo(x) ((x)&0x0F)
#define chr(x)      ((x)>9 ? 'a'+((x)-10) : '0'+(x))

  //  dsc = configuration descriptor
  //  wTotalLength = wTotalLength field of configuration descriptor
  usbdescr_t *dsc = (usbdescr_t*) &(usbdev->usbdesc[((usbdescr_t*) usbdev->usbdesc)->bLength]);
  uint16_t    wTotalLength = HTOUS(*(uint16_t*) dsc->buf);
  dsc = (usbdescr_t*) &dsc->buf[wTotalLength-sizeof(usbdescr_t)];   /* at the first string now  */
  dsc = (usbdescr_t*) &dsc->buf[(dsc->bLength)-sizeof(usbdescr_t)]; /* at the second string now */

  if(dsc->bLength<=24) /* size of utf16-le unicode string containing ieee802.3 address */
  { HAL_BREAKPOINT(); }
  else
  {
    // translation is copied from bridge_aux.c
    dsc->buf[0]  = '0';                   dsc->buf[1]  = '\0';
    dsc->buf[2]  = '0';/*'6';*/           dsc->buf[3]  = '\0';
    dsc->buf[4]  = chr(nibblehi(mac[1])); dsc->buf[5]  = '\0';
    dsc->buf[6]  = chr(nibblelo(mac[1])); dsc->buf[7]  = '\0';
    dsc->buf[8]  = chr(nibblehi(mac[2])); dsc->buf[9]  = '\0';
    dsc->buf[10] = chr(nibblelo(mac[2])); dsc->buf[11] = '\0';
    dsc->buf[12] = chr(nibblehi(mac[5])); dsc->buf[13] = '\0';
    dsc->buf[14] = chr(nibblelo(mac[5])); dsc->buf[15] = '\0';
    dsc->buf[16] = chr(nibblehi(mac[6])); dsc->buf[17] = '\0';
    dsc->buf[18] = chr(nibblelo(mac[6])); dsc->buf[19] = '\0';
    dsc->buf[20] = chr(nibblehi(mac[7])); dsc->buf[21] = '\0';
    dsc->buf[22] = chr(nibblelo(mac[7])); dsc->buf[23] = '\0';
  }
}

usbdev_t usbdev = { /* automatically generated by desc.py */
/* Driver */                   &cdc_process,

/* Default Status   */         { 0x00, 0x00, 0x01, 0x00 },
/* Device Descriptor */        { 0x12, 0x1, 0x10, 0x1, 0x0, 0x0, 0x0, 0x40, 0x6a, 0xb, 0x93, 0xa, 0x0, 0x0, 0x2, 0x3, 0x4, 0x1,
/* Configuration Descriptor */   0x9, 0x2, 0x50, 0x0, 0x2, 0x1, 0x4, 0x0, 0x32, 0x9, 0x4, 0x0, 0x0, 0x1, 0x2, 0x6, 0x0, 0x5, 0x5, 0x24, 0x0, 0x20, 0x1, 0x5, 0x24, 0x6, 0x0, 0x1, 0xd, 0x24, 0xf, 0x1, 0x0, 0x0, 0x0, 0x0, 0x14, 0x5, 0x0, 0x0, 0x0, 0x7, 0x5, 0x83, 0x3, 0x40, 0x0, 0x32, 0x9, 0x4, 0x1, 0x0, 0x0, 0xa, 0x0, 0x0, 0x6, 0x9, 0x4, 0x1, 0x1, 0x2, 0xa, 0x0, 0x0, 0x7, 0x7, 0x5, 0x1, 0x2, 0x40, 0x0, 0x2, 0x7, 0x5, 0x82, 0x2, 0x40, 0x0, 0x2,
/* String Table */               0x8,0x3,0x4,0x0,0x30,0x0,0x39,0x0, 0x1a,0x3,0x64,0x0,0x65,0x0,0x61,0x0,0x64,0x0,0x62,0x0,0x65,0x0,0x65,0x0,0x66,0x0,0x64,0x0,0x65,0x0,0x61,0x0,0x64,0x0, 0x24,0x3,0x4d,0x0,0x61,0x0,0x78,0x0,0x69,0x0,0x6d,0x0,0x2f,0x0,0x4a,0x0,0x65,0x0,0x6e,0x0,0x6e,0x0,0x69,0x0,0x63,0x0,0x2f,0x0,0x54,0x0,0x65,0x0,0x63,0x0,0x6f,0x0, 0x3c,0x3,0x38,0x0,0x30,0x0,0x32,0x0,0x2e,0x0,0x31,0x0,0x35,0x0,0x2e,0x0,0x34,0x0,0x20,0x0,0x49,0x0,0x50,0x0,0x76,0x0,0x36,0x0,0x20,0x0,0x65,0x0,0x74,0x0,0x68,0x0,0x65,0x0,0x72,0x0,0x6e,0x0,0x65,0x0,0x74,0x0,0x20,0x0,0x62,0x0,0x72,0x0,0x69,0x0,0x64,0x0,0x67,0x0,0x65,0x0, 0x2,0x3, 0x10,0x3,0x43,0x0,0x6f,0x0,0x6e,0x0,0x74,0x0,0x72,0x0,0x6f,0x0,0x6c,0x0, 0x12,0x3,0x69,0x0,0x6e,0x0,0x61,0x0,0x63,0x0,0x74,0x0,0x69,0x0,0x76,0x0,0x65,0x0, 0xe,0x3,0x61,0x0,0x63,0x0,0x74,0x0,0x69,0x0,0x76,0x0,0x65,0x0 }
};

PROCESS_THREAD(cdc_process, ev, data)
{
  static struct etimer timer;

  PROCESS_BEGIN();
  enumerated = false;

  /* init the usb stack with our driver and do the mac address hack */
  cdc_set_mac(&usbdev, pvAppApiGetMacAddrLocation());

  /* start usb process if needed */
  if (!process_is_running(&usb_process))
    process_start(&usb_process, NULL);

  /* wait for first usb event */
  PROCESS_YIELD_UNTIL(ev==usb_event && data==EVENT_USB_ENUMERATED);

  /* got enumerated, register with the stack */
  tcpip_set_outputfunc(&cdc_output);
  enumerated = true;

  /* XXX hack to start ethbr process */
  process_start(&ethbr_process, NULL);

  /* loop until disconnected or process exit */
  while(!(ev==usb_event && data==EVENT_USB_DISCONNECTED) &&
        !(ev==PROCESS_EVENT_EXIT) )
  {
    /* poll timer setup */
    etimer_set(&timer, 10);
    PROCESS_YIELD_UNTIL(ev==PROCESS_EVENT_TIMER);

    if (ev==PROCESS_EVENT_EXIT)
      ;
    else if (ev==PROCESS_EVENT_TIMER)
    {
      uint16_t readlen;
      readlen = uip_len = usb_read(EP1, uip_buf, sizeof(uip_buf));

      if (uip_len) {
        cdc_tcpip_input();

        /* linux kernel usb framing bug/feature workaround. There is no
         * zero-length packet ack at the linux kernel cdc_ether driver, but
         * a zero-pad to mark the end of the frame. Since we can't detect when
         * a padding has occured, we assume the packet is either padded or not
         * padded, i.e. send it twice, we different lengths */
        if ((readlen%USBBUFSIZE)==1) {
          mac_LowpanToEthernet();
          uip_len--;
          cdc_tcpip_input();
        }
      }

      uip_len = 0;
    }
  }

  enumerated = false;
  PROCESS_END();
}
